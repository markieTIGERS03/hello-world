#!/usr/bin/env /home/repos/public/Python/bin/python3.6

#Documentation stating API Call volume is rate limited to 5 calls per second per organization.
#https://documentation.meraki.com/zGeneral_Administration/Other_Topics/The_Cisco_Meraki_Dashboard_API#Every_request_must_specify_an_API_key_via_a_request_header

import time
from datetime import datetime
import sys
import os
import getpass
import xlrd
import pathlib
import logging
import threading
from queue import Queue
try:
    from meraki import meraki
except:
    os.system('pip install --user requests')
    os.system('pip install --user meraki')
try:
    print('---loading...')
    from meraki import meraki
except:
    logging.info('installation failed. please contact admin')  
    sys.exit('installation failed. please contact admin')
    
print_lock = threading.Lock()
logFileName = pathlib.Path.cwd() / 'IVAN-MIME-Logs.log'
logging.basicConfig(
    filename=logFileName,
    filemode='a',
    level=logging.DEBUG,
    format='%(asctime)s.%(msecs)03d %(levelname)s: %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
)

def getNetID(myKey, SiteName):
    orgs = meraki.myorgaccess(myKey, suppressprint=True)
    orgNames = [org['name'] for org in orgs]
    index = orgNames.index('IVAN')
    myOrg = orgs[index]['id']
    
    currentNetworks = meraki.getnetworklist(myKey, myOrg, suppressprint=True)
    networkNames = [network['name'] for network in currentNetworks]
    
    mySiteName = 'IVAN-' + SiteName + '-combined'
    myNetID = currentNetworks[networkNames.index(mySiteName)]['id']
    
    myNetworkDevices = meraki.getnetworkdevices(myKey, myNetID, suppressprint=True)
    
    print('---Executing change for Organization: ' + myOrg)
    sys.stdout.flush()
    logging.info('---Executing change for Organization: ' + myOrg)
    print('---Executing change for Site: ' + mySiteName)
    sys.stdout.flush()
    logging.info('---Executing change for Site: ' + mySiteName)
    return myNetID, mySiteName, myNetworkDevices

def getSwitchesOnly(myNetworkDevices):
    #create a list with serial of MS meraki switches ONLY!
    nameList = []
    switchSerialList = []
    modelList = []
    for x in range(len(myNetworkDevices)):
        modelcheck = myNetworkDevices[x]['model']
        if 'MS' in modelcheck:
            switchSerialList.append(myNetworkDevices[x]['serial'])
            modelList.append(myNetworkDevices[x]['model'])
        else:
            continue
    print('Filtered devices to be configured: {}'.format(modelList))
    logging.info('Filtered devices to be configured: {}'.format(modelList))
    print('Filtered devices to be configured: {}'.format(switchSerialList))
    logging.info('Filtered devices to be configured: {}'.format(switchSerialList))
    return switchSerialList, modelList

def updatePolicy(myKey, serialNumber, threadName):
    portnumberList = []
    try:
        perSwitchPortDetails = meraki.getswitchports(myKey, serialNumber, suppressprint=True)
    except:
        upd8Status = 'unable to get switch port. check serial: ' + serialNumber
        return upd8Status
    for x in range(len(perSwitchPortDetails)):
        typecheck = perSwitchPortDetails[x]['type']
        vlancheck = perSwitchPortDetails[x]['vlan']
        if 'access' in str(typecheck):
            if '201' in str(vlancheck):
                portnumber = perSwitchPortDetails[x]['number']
                portnumberList.append(portnumber)
            else:
                pass
        else:
            continue
    with print_lock:
        logging.info('Ports with vlan 201 {}'.format(portnumberList))
    myFilePath = pathlib.Path.cwd() / 'MIME-Push-Status'    
    for port in portnumberList:
        try:
            result = meraki.updateswitchport(myKey, serialNumber, port, accesspolicynum='1', suppressprint=True)
        except:
            upd8Status = 'unable to update switch port policy. no access vlan 201 in switch: ' + serialNumber
            return upd8Status
        logging.info(result)
        #with print_lock:
        #if type(result) is dict:
        #    status = serialNumber + ': ' + port + ' Configured Success'
        #    with open(myFilePath, 'a') as myFile:
        #        myFile.write(status)
        #else:
        #    status = serialNumber + ': ' + port + ' Configured Failed'
        #    with open(myFilePath, 'a') as myFile:
        #        myFile.write(status)
    try:
        postPerSwitchPortDetails = meraki.getswitchports(myKey, serialNumber, suppressprint=True)
    except:
        upd8Status = 'unable to get POST switch port. check serial: ' + serialNumber
        return upd8Status
    index = 0
    for x in range(len(postPerSwitchPortDetails)):
        policyNumCheck = postPerSwitchPortDetails[x]['accessPolicyNumber']
        if '1' in str(policyNumCheck):
            with print_lock:
                logging.info('{0:2} {1:12}: {2:15} {3:6} {4:7} {5:6} {6:10}'.format(index+1, threadName, serialNumber, postPerSwitchPortDetails[x]['number'], postPerSwitchPortDetails[x]['type'], postPerSwitchPortDetails[x]['vlan'], postPerSwitchPortDetails[x]['accessPolicyNumber']))
                print('{0:2} {1:12}: {2:15} {3:6} {4:7} {5:6} {6:10}'.format(index+1, threadName, serialNumber, postPerSwitchPortDetails[x]['number'], postPerSwitchPortDetails[x]['type'], postPerSwitchPortDetails[x]['vlan'], postPerSwitchPortDetails[x]['accessPolicyNumber']))
                sys.stdout.flush()
            index += 1 # increment our index
        else:
            logging.info('Policy check failed for {}'.format(x))
            pass
    upd8Status = 'Successfully update access policy for serial: ' + serialNumber
    return upd8Status

def worker(myKey):
    threadName = threading.current_thread().getName()
    while (q.qsize() != 0):
        try:
            serialNumber = q.get()
            logging.info('{} updating policy for serial: {}'.format(threadName, serialNumber))
            status = updatePolicy(myKey, serialNumber, threadName)
            logging.info(status)
            q.task_done()
        except:
            return


########################## MAIN ##########################
userID = os.getlogin()
logging.info('---Start MIME Script execution by: ' + userID)
os.system('clear')
try:
    G_Key = getpass.getpass('---Enter API Key (Press Ctrl + C to exit): ')
    G_Site = input('---Enter IVAN Sitename: ')
    G_myNetID, G_mySiteName, G_myNetworkDevices = getNetID(G_Key, G_Site)
    G_switchSerialList, G_modelList = getSwitchesOnly(G_myNetworkDevices)
except:
    sys.exit('Phase I Error. Exiting code...')
try:
    answer1 = input('---Do you want to proceed (Y/N, Default=N): ').lower()
    if answer1 in ['yes', 'y']:
        pass
    else:
        logging.info('---Choose not to proceed. Exiting code')
        sys.exit('---Choose not to proceed. Exiting code')
except:
    logging.info('---Phase II Error. Exiting code')
    sys.exit('---Phase II Error. Exiting code')

q = Queue()
for item in G_switchSerialList:
    q.put(item)
maxAllowedThread = min(3, q.qsize())
threadList = []
#print summary before start execution
print('Total number of Device queued: {}'.format(q.qsize()))
logging.info('Total number of Device queued: {}'.format(q.qsize()))
print('Starting {0} threads at a time.'.format(maxAllowedThread))
print('Summary:')
print('')
print('Idx Thread Name  Serial Number   Port#  Type    Vlan   PolicyNum')
print('--- ------------ --------------- ------ ------- ------ ----------')
start = time.time()
for i in range(maxAllowedThread):
    t = threading.Thread(target = worker, args = (G_Key,))
    t.daemon = True
    t.start()
    threadList.append(t)
    logging.info('---Starting thread {}'.format(i))
[t.join() for t in threadList]
q.join()

#myFilePath = pathlib.Path.cwd() / 'MIME-Push-Status'
#with open(myFilePath, 'r') as f:
#    summary = [line.strip() for line in f]     

print('-' * 52)
#for line in summary:
#    print(line)
print('')
print('Script run by: {}'.format(userID))
print('Total script runtime: {}'.format(time.time()-start))
print('---End of code')
exit()
